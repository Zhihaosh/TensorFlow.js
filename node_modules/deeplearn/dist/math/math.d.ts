import { BackendType } from '../environment';
import { NamedArrayMap, NamedVariableMap } from '../util';
import { MathBackend } from './backends/backend';
import { BackendEngine } from './backends/backend_engine';
import { TapeNodeInputGradientArrays } from './backends/tape_types';
import { ScopeResult, ScopeResultImmediate } from './backends/tape_util';
import { MatrixOrientation } from './backends/types/matmul';
import { Array1D, Array2D, Array3D, Array4D, DataType, DataTypeMap, NDArray, Rank, RankMap, Scalar, Variable } from './ndarray';
import { SumTypes } from './types';
export interface LSTMCell {
    (data: Array2D, c: Array2D, h: Array2D): [Array2D, Array2D];
}
export interface NDArrayManager {
    getNumArrays(): number;
    register(a: NDArray): void;
    registerVariable(v: Variable): void;
}
export declare class NDArrayMath implements NDArrayManager {
    protected backendEngine: BackendEngine;
    private registeredArrays;
    private backend;
    private customBackend;
    registeredVariables: NamedVariableMap;
    time(query: () => NDArray): Promise<number>;
    getNumArrays(): number;
    register(a: NDArray | Variable): void;
    registerVariable(v: Variable): void;
    writePixels(dataId: number, pixels: ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement, numChannels: number): void;
    write<D extends DataType>(dataId: number, values: DataTypeMap[D]): void;
    readSync<D extends DataType>(dataId: number): DataTypeMap[D];
    read<D extends DataType>(dataId: number): Promise<DataTypeMap[D]>;
    constructor(backend: BackendType | MathBackend, safeMode: boolean);
    enableDebugMode(): void;
    scope<T extends ScopeResult>(scopeFn: (keep: <T1 extends NDArray>(ndarray: T1) => T1, track: <T2 extends NDArray>(ndarray: T2) => T2) => T): T;
    gradientsScope<T extends ScopeResult>(scopeFn: (keep: <D1 extends DataType, T1 extends NDArray<D1>>(ndarray: T1) => T1, track: <D2 extends DataType, T2 extends NDArray<D2>>(ndarray: T2) => T2) => T): T;
    startScope(): void;
    endScope(result: ScopeResultImmediate): void;
    keep<T extends NDArray>(result: T): T;
    track<T extends NDArray>(result: T): T;
    dispose(): void;
    matMul(a: Array2D, b: Array2D, aOrientation?: MatrixOrientation, bOrientation?: MatrixOrientation): Array2D;
    private executeOp<T>(name, f);
    vectorTimesMatrix(v: Array1D, matrix: Array2D): Array1D;
    matrixTimesVector(matrix: Array2D, v: Array1D): Array1D;
    dotProduct(v1: Array1D, v2: Array1D): Scalar;
    outerProduct(v1: Array1D, v2: Array1D): Array2D;
    clone<T extends NDArray>(x: T): T;
    reshape<D extends DataType, R extends Rank, T extends RankMap<D>[R]>(x: NDArray<D>, newShape: number[]): T;
    cast<D extends DataType, R extends Rank>(x: NDArray<DataType, R>, newDType: D): RankMap<D>[R];
    slice1D(x: Array1D, begin: number, size: number): Array1D;
    slice2D(x: Array2D, begin: [number, number], size: [number, number]): Array2D;
    slice3D(x: Array3D, begin: [number, number, number], size: [number, number, number]): Array3D;
    slice4D(x: Array4D, begin: [number, number, number, number], size: [number, number, number, number]): Array4D;
    reverse1D(x: Array1D): Array1D;
    reverse2D(x: Array2D, axis: number | number[]): Array2D;
    reverse3D(x: Array3D, axis: number | number[]): Array3D;
    reverse4D(x: Array4D, axis: number | number[]): Array4D;
    concat1D(a: Array1D, b: Array1D): Array1D;
    concat2D(a: Array2D, b: Array2D, axis: number): Array2D;
    concat3D(a: Array3D, b: Array3D, axis: number): Array3D;
    concat4D(a: Array4D, b: Array4D, axis: number): Array4D;
    logSumExp<T extends NDArray<'float32'>>(input: NDArray, axis?: number | number[], keepDims?: boolean): T;
    sum<D extends DataType, T extends NDArray<SumTypes[D]>>(x: NDArray<D>, axis?: number | number[], keepDims?: boolean): T;
    mean(x: NDArray, axis?: number | number[], keepDims?: boolean): NDArray<'float32'>;
    argMin<T extends NDArray<'int32'>>(x: NDArray, axis?: number): T;
    argMax<T extends NDArray<'int32'>>(x: NDArray, axis?: number): T;
    argMaxEquals(x1: NDArray, x2: NDArray): Scalar<'bool'>;
    equal<D1 extends DataType, D2 extends D1, T extends NDArray<'bool'>>(a: NDArray<D1>, b: NDArray<D2>): T;
    equalStrict<T extends NDArray>(a: T, b: T): NDArray<'bool'>;
    notEqual<D1 extends DataType, D2 extends D1, T extends NDArray<'bool'>>(a: NDArray<D1>, b: NDArray<D2>): T;
    notEqualStrict<R extends Rank, D1 extends DataType, D2 extends D1>(a: NDArray<D1, R>, b: NDArray<D2, R>): RankMap<'bool'>[R];
    lessEqual<D1 extends DataType, D2 extends D1, T extends NDArray<'bool'>>(a: NDArray<D1>, b: NDArray<D2>): T;
    greater<D1 extends DataType, D2 extends D1, T extends NDArray<'bool'>>(a: NDArray<D1>, b: NDArray<D2>): T;
    greaterEqual<D1 extends DataType, D2 extends D1, T extends NDArray<'bool'>>(a: NDArray<D1>, b: NDArray<D2>): T;
    logicalOr(a: NDArray<'bool'>, b: NDArray<'bool'>): NDArray<'bool'>;
    topK(x: NDArray, k: number): {
        values: Array1D;
        indices: Array1D<'int32'>;
    };
    min<D extends DataType, T extends NDArray<D>>(x: NDArray<D>, axis?: number | number[], keepDims?: boolean): T;
    minimum<D1 extends DataType, D2 extends D1, T extends NDArray<D1>>(a: NDArray<D1>, b: NDArray<D2>): T;
    max<D extends DataType, T extends NDArray<D>>(x: NDArray<D>, axis?: number | number[], keepDims?: boolean): T;
    maximum<D1 extends DataType, D2 extends D1, T extends NDArray<D1>>(a: NDArray<D1>, b: NDArray<D2>): T;
    softmax<D extends DataType, R extends Rank>(logits: NDArray<D, R>, dim?: number): RankMap<'float32'>[R];
    softmaxCrossEntropyWithLogits<R extends Rank, A extends NDArray<DataType, R>, B extends NDArray<DataType, R>, O extends NDArray<'float32'>>(labels: A, logits: B, dim?: number): O;
    switchDim<T extends NDArray>(a: T, newDim: number[]): T;
    tile<D extends DataType, T extends NDArray<D>>(x: T, reps: number[]): T;
    pad1D(x: Array1D, paddings: [number, number], constantValue?: number): Array1D;
    pad2D(x: Array2D, paddings: [[number, number], [number, number]], constantValue?: number): Array2D;
    transpose<T extends NDArray>(x: T, perm?: number[]): T;
    scalarPlusArray<T extends NDArray>(c: Scalar, a: T): T;
    scalarMinusArray<T extends NDArray>(c: Scalar, a: T): T;
    arrayMinusScalar<T extends NDArray>(a: T, c: Scalar): T;
    neg<T extends NDArray>(x: T): T;
    add<D1 extends DataType, D2 extends D1, T extends NDArray<D1>>(a: NDArray<D1>, b: NDArray<D2>): T;
    addStrict<T extends NDArray>(a: T, b: T): T;
    subtract<D1 extends DataType, D2 extends D1, T extends NDArray<D1>>(a: NDArray<D1>, b: NDArray<D2>): T;
    pow<D extends DataType, T extends NDArray<D>>(a: NDArray<D>, b: NDArray<'int32'>): T;
    powStrict<D extends DataType>(a: NDArray<D>, b: NDArray<'int32'>): NDArray<D>;
    sub<D1 extends DataType, D2 extends D1, T extends NDArray<D1>>(a: NDArray<D1>, b: NDArray<D2>): T;
    subStrict<T extends NDArray>(a: T, b: T): T;
    multiply<D1 extends DataType, D2 extends D1, T extends NDArray<D1>>(a: NDArray<D1>, b: NDArray<D2>): T;
    elementWiseMul<T extends NDArray>(a: T, b: T): T;
    multiplyStrict<T extends NDArray>(a: T, b: T): T;
    divide<T extends NDArray<'float32'>>(a: NDArray, b: NDArray): T;
    divideStrict<T extends NDArray>(a: T, b: T): T;
    scalarDividedByArray<T extends NDArray>(c: Scalar, a: T): T;
    arrayDividedByScalar<T extends NDArray>(a: T, c: Scalar): T;
    ceil<T extends NDArray>(x: T): T;
    floor<T extends NDArray>(x: T): T;
    exp<T extends NDArray>(x: T): T;
    log<T extends NDArray>(x: T): T;
    sqrt<T extends NDArray>(x: T): T;
    square<D extends DataType, R extends Rank, T extends NDArray<D, R>>(x: T): T;
    abs<T extends NDArray>(x: T): T;
    clip<T extends NDArray>(x: T, min: number, max: number): T;
    relu<D extends DataType, R extends Rank, T extends NDArray<D, R>>(x: T): T;
    elu<T extends NDArray>(x: T): T;
    eluDer<T extends NDArray>(x: T): T;
    selu<T extends NDArray>(x: T): T;
    leakyRelu<T extends NDArray>(x: T, alpha?: number): T;
    prelu<T extends NDArray>(x: T, alpha: T): T;
    preluDer<T extends NDArray>(x: T, alpha: T): T;
    sigmoid<T extends NDArray>(x: T): T;
    sin<T extends NDArray>(x: T): T;
    cos<T extends NDArray>(x: T): T;
    tan<T extends NDArray>(x: T): T;
    asin<T extends NDArray>(x: T): T;
    acos<T extends NDArray>(x: T): T;
    atan<T extends NDArray>(x: T): T;
    sinh<T extends NDArray>(x: T): T;
    cosh<T extends NDArray>(x: T): T;
    tanh<T extends NDArray>(x: T): T;
    step<T extends NDArray>(x: T, alpha?: number): T;
    scaledArrayAdd<T extends NDArray>(c1: Scalar, a: T, c2: Scalar, b: T): T;
    scalarTimesArray<T extends NDArray>(c: Scalar, a: T): T;
    elementWiseMulBroadcast(a: Array2D, b: Array2D): Array2D;
    conv1d<T extends NDArray>(input: T, filter: Array3D, bias: Array1D | null, stride: number, pad: 'valid' | 'same' | number, dimRoundingMode?: 'floor' | 'round' | 'ceil'): T;
    conv2d<T extends Array3D | Array4D>(x: T, filter: Array4D, bias: Array1D | null, strides: [number, number] | number, pad: 'valid' | 'same' | number, dimRoundingMode?: 'floor' | 'round' | 'ceil'): T;
    conv2dDerInput<T extends NDArray>(xShape: [number, number, number, number] | [number, number, number], dy: T, filter: Array4D, strides: [number, number] | number, pad: 'valid' | 'same' | number, dimRoundingMode?: 'floor' | 'round' | 'ceil'): T;
    conv2dDerBias(dy: Array3D | Array4D): Array1D;
    conv2dDerFilter<T extends Array3D | Array4D>(x: T, dy: T, filterShape: [number, number, number, number], strides: [number, number] | number, pad: 'valid' | 'same' | number, dimRoundingMode?: 'floor' | 'round' | 'ceil'): Array4D;
    conv2dTranspose<T extends NDArray>(x: T, filter: Array4D, outputShape: [number, number, number, number] | [number, number, number], strides: [number, number] | number, pad: 'valid' | 'same' | number, dimRoundingMode?: 'floor' | 'round' | 'ceil'): T;
    depthwiseConv2D<T extends NDArray>(input: T, filter: Array4D, strides: [number, number] | number, pad: 'valid' | 'same' | number, rates?: [number, number] | number, dimRoundingMode?: 'floor' | 'round' | 'ceil'): T;
    maxPool<T extends NDArray>(x: T, filterSize: [number, number] | number, strides: [number, number] | number, pad: 'valid' | 'same' | number, dimRoundingMode?: 'floor' | 'round' | 'ceil'): T;
    maxPoolBackprop<T extends NDArray>(dy: T, input: T, filterSize: [number, number] | number, strides: [number, number] | number, pad: 'valid' | 'same' | number, dimRoundingMode?: 'floor' | 'round' | 'ceil'): T;
    minPool<T extends NDArray>(input: T, filterSize: [number, number] | number, strides: [number, number] | number, pad: 'valid' | 'same' | number, dimRoundingMode?: 'floor' | 'round' | 'ceil'): T;
    avgPool<R extends '3' | '4'>(x: NDArray<'int32' | 'float32', R>, filterSize: [number, number] | number, strides: [number, number] | number, pad: 'valid' | 'same' | number, dimRoundingMode?: 'floor' | 'round' | 'ceil'): RankMap<'float32'>[R];
    private avgPoolBackprop<T>(dy, input, filterSize, strides, pad);
    resizeBilinear3D(x: Array3D, newShape2D: [number, number], alignCorners?: boolean): Array3D;
    batchNormalization2D(x: Array2D, mean: Array2D | Array1D, variance: Array2D | Array1D, varianceEpsilon?: number, scale?: Array2D | Array1D, offset?: Array2D | Array1D): Array2D;
    batchNormalization3D(x: Array3D, mean: Array3D | Array1D, variance: Array3D | Array1D, varianceEpsilon?: number, scale?: Array3D | Array1D, offset?: Array3D | Array1D): Array3D;
    batchNormalization4D(x: Array4D, mean: Array4D | Array1D, variance: Array4D | Array1D, varianceEpsilon?: number, scale?: Array4D | Array1D, offset?: Array4D | Array1D): Array4D;
    localResponseNormalization3D(x: Array3D, radius?: number, bias?: number, alpha?: number, beta?: number, normRegion?: 'acrossChannels' | 'withinChannel'): Array3D;
    localResponseNormalization4D(x: Array4D, radius?: number, bias?: number, alpha?: number, beta?: number, normRegion?: 'acrossChannels' | 'withinChannel'): Array4D;
    multiRNNCell(lstmCells: LSTMCell[], data: Array2D, c: Array2D[], h: Array2D[]): [Array2D[], Array2D[]];
    basicLSTMCell(forgetBias: Scalar, lstmKernel: Array2D, lstmBias: Array1D, data: Array2D, c: Array2D, h: Array2D): [Array2D, Array2D];
    multinomial(probabilities: Array1D | Array2D, numSamples: number, seed?: number): Array1D<'int32'> | Array2D<'int32'>;
    oneHot(indices: Array1D, depth: number, onValue?: number, offValue?: number): Array2D;
    moments(x: NDArray, axis?: number | number[], keepDims?: boolean): {
        mean: NDArray<'float32'>;
        variance: NDArray<'float32'>;
    };
    norm<D extends DataType>(x: NDArray<D>, ord?: number | 'euclidean' | 'fro', axis?: number | number[], keepDims?: boolean): NDArray<D | SumTypes[D]>;
    private normInternal<D>(x, p, axis?);
    vjp<T extends NDArray | NamedArrayMap, R extends Rank>(f: () => NDArray<DataType, R>, x: T, dy: NDArray<'float32', R>): T;
    gradients<T extends NDArray | NamedArrayMap, D extends DataType>(f: () => Scalar<D>, x: T): T;
    variableGradients<D extends DataType>(f: () => Scalar<D>): {
        value: Scalar<D>;
        gradients: NamedVariableMap;
    };
    valueAndGradients<T extends NDArray | NamedArrayMap, D extends DataType>(f: () => Scalar<D>, x: T): {
        value: Scalar;
        gradients: T;
    };
    customGradient<D extends DataType, R extends Rank>(f: () => {
        value: NDArray<D, R>;
        gradients: (dy: NDArray<'float32', R>, y: NDArray<D, R>) => TapeNodeInputGradientArrays;
    }, inputs: NamedArrayMap, name?: string): NDArray<D, R>;
    disposeData(dataId: number): void;
}
